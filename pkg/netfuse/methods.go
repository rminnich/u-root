// Copyright 2019 the u-root Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file is generated by gen.go. Only edit it for debugging purposes.

package netfuse

import (
	"context"
	"fmt"

	"github.com/u-root/fuse/fuseops"
)

// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
// Errors must be sent as strings.

// RespReleaseFileHandle is used to transmit ReleaseFileHandle responses to the client.
type RespReleaseFileHandle struct {
	fuseops.ReleaseFileHandleOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// ReleaseFileHandle implements ReleaseFileHandle on the RPC server side.
func (id FSID) ReleaseFileHandle(req *fuseops.ReleaseFileHandleOp, resp *RespReleaseFileHandle) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.ReleaseFileHandle(context.TODO(), req))
	resp.ReleaseFileHandleOp = *req
	return nil
}

// ReleaseFileHandle implements ReleaseFileHandle on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) ReleaseFileHandle(ctx context.Context, op *fuseops.ReleaseFileHandleOp) error {
	var resp = &RespReleaseFileHandle{}
	err := fs.Call("FSID.ReleaseFileHandle", op, resp)
	if err != nil {
		return err
	}
	*op = resp.ReleaseFileHandleOp
	return StringToErr(resp.Err)
}

// RespMkDir is used to transmit MkDir responses to the client.
type RespMkDir struct {
	fuseops.MkDirOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// MkDir implements MkDir on the RPC server side.
func (id FSID) MkDir(req *fuseops.MkDirOp, resp *RespMkDir) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.MkDir(context.TODO(), req))
	resp.MkDirOp = *req
	return nil
}

// MkDir implements MkDir on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) MkDir(ctx context.Context, op *fuseops.MkDirOp) error {
	var resp = &RespMkDir{}
	err := fs.Call("FSID.MkDir", op, resp)
	if err != nil {
		return err
	}
	*op = resp.MkDirOp
	return StringToErr(resp.Err)
}

// RespStatFS is used to transmit StatFS responses to the client.
type RespStatFS struct {
	fuseops.StatFSOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// StatFS implements StatFS on the RPC server side.
func (id FSID) StatFS(req *fuseops.StatFSOp, resp *RespStatFS) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.StatFS(context.TODO(), req))
	resp.StatFSOp = *req
	return nil
}

// StatFS implements StatFS on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) StatFS(ctx context.Context, op *fuseops.StatFSOp) error {
	var resp = &RespStatFS{}
	err := fs.Call("FSID.StatFS", op, resp)
	if err != nil {
		return err
	}
	*op = resp.StatFSOp
	return StringToErr(resp.Err)
}

// RespSetInodeAttributes is used to transmit SetInodeAttributes responses to the client.
type RespSetInodeAttributes struct {
	fuseops.SetInodeAttributesOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// SetInodeAttributes implements SetInodeAttributes on the RPC server side.
func (id FSID) SetInodeAttributes(req *fuseops.SetInodeAttributesOp, resp *RespSetInodeAttributes) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.SetInodeAttributes(context.TODO(), req))
	resp.SetInodeAttributesOp = *req
	return nil
}

// SetInodeAttributes implements SetInodeAttributes on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) SetInodeAttributes(ctx context.Context, op *fuseops.SetInodeAttributesOp) error {
	var resp = &RespSetInodeAttributes{}
	err := fs.Call("FSID.SetInodeAttributes", op, resp)
	if err != nil {
		return err
	}
	*op = resp.SetInodeAttributesOp
	return StringToErr(resp.Err)
}

// RespMkNode is used to transmit MkNode responses to the client.
type RespMkNode struct {
	fuseops.MkNodeOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// MkNode implements MkNode on the RPC server side.
func (id FSID) MkNode(req *fuseops.MkNodeOp, resp *RespMkNode) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.MkNode(context.TODO(), req))
	resp.MkNodeOp = *req
	return nil
}

// MkNode implements MkNode on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) MkNode(ctx context.Context, op *fuseops.MkNodeOp) error {
	var resp = &RespMkNode{}
	err := fs.Call("FSID.MkNode", op, resp)
	if err != nil {
		return err
	}
	*op = resp.MkNodeOp
	return StringToErr(resp.Err)
}

// RespCreateFile is used to transmit CreateFile responses to the client.
type RespCreateFile struct {
	fuseops.CreateFileOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// CreateFile implements CreateFile on the RPC server side.
func (id FSID) CreateFile(req *fuseops.CreateFileOp, resp *RespCreateFile) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.CreateFile(context.TODO(), req))
	resp.CreateFileOp = *req
	return nil
}

// CreateFile implements CreateFile on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) CreateFile(ctx context.Context, op *fuseops.CreateFileOp) error {
	var resp = &RespCreateFile{}
	err := fs.Call("FSID.CreateFile", op, resp)
	if err != nil {
		return err
	}
	*op = resp.CreateFileOp
	return StringToErr(resp.Err)
}

// RespCreateSymlink is used to transmit CreateSymlink responses to the client.
type RespCreateSymlink struct {
	fuseops.CreateSymlinkOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// CreateSymlink implements CreateSymlink on the RPC server side.
func (id FSID) CreateSymlink(req *fuseops.CreateSymlinkOp, resp *RespCreateSymlink) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.CreateSymlink(context.TODO(), req))
	resp.CreateSymlinkOp = *req
	return nil
}

// CreateSymlink implements CreateSymlink on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) CreateSymlink(ctx context.Context, op *fuseops.CreateSymlinkOp) error {
	var resp = &RespCreateSymlink{}
	err := fs.Call("FSID.CreateSymlink", op, resp)
	if err != nil {
		return err
	}
	*op = resp.CreateSymlinkOp
	return StringToErr(resp.Err)
}

// RespCreateLink is used to transmit CreateLink responses to the client.
type RespCreateLink struct {
	fuseops.CreateLinkOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// CreateLink implements CreateLink on the RPC server side.
func (id FSID) CreateLink(req *fuseops.CreateLinkOp, resp *RespCreateLink) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.CreateLink(context.TODO(), req))
	resp.CreateLinkOp = *req
	return nil
}

// CreateLink implements CreateLink on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) CreateLink(ctx context.Context, op *fuseops.CreateLinkOp) error {
	var resp = &RespCreateLink{}
	err := fs.Call("FSID.CreateLink", op, resp)
	if err != nil {
		return err
	}
	*op = resp.CreateLinkOp
	return StringToErr(resp.Err)
}

// RespRename is used to transmit Rename responses to the client.
type RespRename struct {
	fuseops.RenameOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// Rename implements Rename on the RPC server side.
func (id FSID) Rename(req *fuseops.RenameOp, resp *RespRename) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.Rename(context.TODO(), req))
	resp.RenameOp = *req
	return nil
}

// Rename implements Rename on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) Rename(ctx context.Context, op *fuseops.RenameOp) error {
	var resp = &RespRename{}
	err := fs.Call("FSID.Rename", op, resp)
	if err != nil {
		return err
	}
	*op = resp.RenameOp
	return StringToErr(resp.Err)
}

// RespRmDir is used to transmit RmDir responses to the client.
type RespRmDir struct {
	fuseops.RmDirOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// RmDir implements RmDir on the RPC server side.
func (id FSID) RmDir(req *fuseops.RmDirOp, resp *RespRmDir) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.RmDir(context.TODO(), req))
	resp.RmDirOp = *req
	return nil
}

// RmDir implements RmDir on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) RmDir(ctx context.Context, op *fuseops.RmDirOp) error {
	var resp = &RespRmDir{}
	err := fs.Call("FSID.RmDir", op, resp)
	if err != nil {
		return err
	}
	*op = resp.RmDirOp
	return StringToErr(resp.Err)
}

// RespUnlink is used to transmit Unlink responses to the client.
type RespUnlink struct {
	fuseops.UnlinkOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// Unlink implements Unlink on the RPC server side.
func (id FSID) Unlink(req *fuseops.UnlinkOp, resp *RespUnlink) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.Unlink(context.TODO(), req))
	resp.UnlinkOp = *req
	return nil
}

// Unlink implements Unlink on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) Unlink(ctx context.Context, op *fuseops.UnlinkOp) error {
	var resp = &RespUnlink{}
	err := fs.Call("FSID.Unlink", op, resp)
	if err != nil {
		return err
	}
	*op = resp.UnlinkOp
	return StringToErr(resp.Err)
}

// RespOpenFile is used to transmit OpenFile responses to the client.
type RespOpenFile struct {
	fuseops.OpenFileOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// OpenFile implements OpenFile on the RPC server side.
func (id FSID) OpenFile(req *fuseops.OpenFileOp, resp *RespOpenFile) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.OpenFile(context.TODO(), req))
	resp.OpenFileOp = *req
	return nil
}

// OpenFile implements OpenFile on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) OpenFile(ctx context.Context, op *fuseops.OpenFileOp) error {
	var resp = &RespOpenFile{}
	err := fs.Call("FSID.OpenFile", op, resp)
	if err != nil {
		return err
	}
	*op = resp.OpenFileOp
	return StringToErr(resp.Err)
}

// RespReadSymlink is used to transmit ReadSymlink responses to the client.
type RespReadSymlink struct {
	fuseops.ReadSymlinkOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// ReadSymlink implements ReadSymlink on the RPC server side.
func (id FSID) ReadSymlink(req *fuseops.ReadSymlinkOp, resp *RespReadSymlink) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.ReadSymlink(context.TODO(), req))
	resp.ReadSymlinkOp = *req
	return nil
}

// ReadSymlink implements ReadSymlink on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) ReadSymlink(ctx context.Context, op *fuseops.ReadSymlinkOp) error {
	var resp = &RespReadSymlink{}
	err := fs.Call("FSID.ReadSymlink", op, resp)
	if err != nil {
		return err
	}
	*op = resp.ReadSymlinkOp
	return StringToErr(resp.Err)
}

// RespOpenDir is used to transmit OpenDir responses to the client.
type RespOpenDir struct {
	fuseops.OpenDirOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// OpenDir implements OpenDir on the RPC server side.
func (id FSID) OpenDir(req *fuseops.OpenDirOp, resp *RespOpenDir) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.OpenDir(context.TODO(), req))
	resp.OpenDirOp = *req
	return nil
}

// OpenDir implements OpenDir on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) OpenDir(ctx context.Context, op *fuseops.OpenDirOp) error {
	var resp = &RespOpenDir{}
	err := fs.Call("FSID.OpenDir", op, resp)
	if err != nil {
		return err
	}
	*op = resp.OpenDirOp
	return StringToErr(resp.Err)
}

// RespForgetInode is used to transmit ForgetInode responses to the client.
type RespForgetInode struct {
	fuseops.ForgetInodeOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// ForgetInode implements ForgetInode on the RPC server side.
func (id FSID) ForgetInode(req *fuseops.ForgetInodeOp, resp *RespForgetInode) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.ForgetInode(context.TODO(), req))
	resp.ForgetInodeOp = *req
	return nil
}

// ForgetInode implements ForgetInode on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) ForgetInode(ctx context.Context, op *fuseops.ForgetInodeOp) error {
	var resp = &RespForgetInode{}
	err := fs.Call("FSID.ForgetInode", op, resp)
	if err != nil {
		return err
	}
	*op = resp.ForgetInodeOp
	return StringToErr(resp.Err)
}

// RespReleaseDirHandle is used to transmit ReleaseDirHandle responses to the client.
type RespReleaseDirHandle struct {
	fuseops.ReleaseDirHandleOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// ReleaseDirHandle implements ReleaseDirHandle on the RPC server side.
func (id FSID) ReleaseDirHandle(req *fuseops.ReleaseDirHandleOp, resp *RespReleaseDirHandle) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.ReleaseDirHandle(context.TODO(), req))
	resp.ReleaseDirHandleOp = *req
	return nil
}

// ReleaseDirHandle implements ReleaseDirHandle on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) ReleaseDirHandle(ctx context.Context, op *fuseops.ReleaseDirHandleOp) error {
	var resp = &RespReleaseDirHandle{}
	err := fs.Call("FSID.ReleaseDirHandle", op, resp)
	if err != nil {
		return err
	}
	*op = resp.ReleaseDirHandleOp
	return StringToErr(resp.Err)
}

// RespGetInodeAttributes is used to transmit GetInodeAttributes responses to the client.
type RespGetInodeAttributes struct {
	fuseops.GetInodeAttributesOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// GetInodeAttributes implements GetInodeAttributes on the RPC server side.
func (id FSID) GetInodeAttributes(req *fuseops.GetInodeAttributesOp, resp *RespGetInodeAttributes) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.GetInodeAttributes(context.TODO(), req))
	resp.GetInodeAttributesOp = *req
	return nil
}

// GetInodeAttributes implements GetInodeAttributes on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) GetInodeAttributes(ctx context.Context, op *fuseops.GetInodeAttributesOp) error {
	var resp = &RespGetInodeAttributes{}
	err := fs.Call("FSID.GetInodeAttributes", op, resp)
	if err != nil {
		return err
	}
	*op = resp.GetInodeAttributesOp
	return StringToErr(resp.Err)
}

// RespLookUpInode is used to transmit LookUpInode responses to the client.
type RespLookUpInode struct {
	fuseops.LookUpInodeOp
	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.

	Err string
}

// LookUpInode implements LookUpInode on the RPC server side.
func (id FSID) LookUpInode(req *fuseops.LookUpInodeOp, resp *RespLookUpInode) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.LookUpInode(context.TODO(), req))
	resp.LookUpInodeOp = *req
	return nil
}

// LookUpInode implements LookUpInode on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) LookUpInode(ctx context.Context, op *fuseops.LookUpInodeOp) error {
	var resp = &RespLookUpInode{}
	err := fs.Call("FSID.LookUpInode", op, resp)
	if err != nil {
		return err
	}
	*op = resp.LookUpInodeOp
	return StringToErr(resp.Err)
}

// RespWriteFile is used to transmit WriteFile responses to the client.
type RespWriteFile struct {
	// BytesWritten is the number of bytes written
	BytesWritten int

	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.
	Err string
}

// WriteFile implements WriteFile on the RPC server side.
func (id FSID) WriteFile(req *fuseops.WriteFileOp, resp *RespWriteFile) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	resp.Err = ErrToString(fs.WriteFile(context.TODO(), req))
	resp.BytesWritten = len(req.Data)
	return nil
}

// WriteFile implements WriteFile on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) WriteFile(ctx context.Context, op *fuseops.WriteFileOp) error {
	var resp = &RespWriteFile{}
	err := fs.Call("FSID.WriteFile", op, resp)
	if err != nil {
		return err
	}
	if resp.BytesWritten < 0 {
		op.Data = []byte{}
	} else {
		op.Data = op.Data[:resp.BytesWritten]
	}

	return StringToErr(resp.Err)
}

// ReqReadFile is used to transmit ReadFile resquests to the server.
type ReqReadFile struct {
	// The file inode that we are reading, and the handle previously returned by
	// CreateFile or OpenFile when opening that inode.
	Inode  fuseops.InodeID
	Handle fuseops.HandleID

	// The offset within the file at which to read.
	Offset    int64
	BytesRead int
}

// RespReadFile is used to transmit ReadFile responses to the client.
type RespReadFile struct {
	// Dst is the data from the read.
	Dst []byte

	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.
	Err string
}

// ReadFile implements ReadFile on the RPC server side.
func (id FSID) ReadFile(req *ReqReadFile, resp *RespReadFile) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	var r = &fuseops.ReadFileOp{
		Inode:  req.Inode,
		Handle: req.Handle,
		Offset: int64(req.Offset),
		Dst:    make([]byte, req.BytesRead),
	}

	resp.Err = ErrToString(fs.ReadFile(context.TODO(), r))
	if r.BytesRead > 0 {
		resp.Dst = r.Dst[:r.BytesRead]
	}
	return nil
}

// ReadFile implements ReadFile on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) ReadFile(ctx context.Context, op *fuseops.ReadFileOp) error {
	var resp = &RespReadFile{}
	var req = &ReqReadFile{
		Inode:     op.Inode,
		Handle:    op.Handle,
		Offset:    int64(op.Offset),
		BytesRead: len(op.Dst),
	}
	err := fs.Call("FSID.ReadFile", req, resp)
	if err != nil {
		return err
	}
	copy(op.Dst, resp.Dst)
	op.BytesRead = len(resp.Dst)
	return StringToErr(resp.Err)
}

// ReqReadDir is used to transmit ReadDir resquests to the server.
type ReqReadDir struct {
	// The file inode that we are reading, and the handle previously returned by
	// CreateFile or OpenFile when opening that inode.
	Inode  fuseops.InodeID
	Handle fuseops.HandleID

	// The offset within the file at which to read.
	Offset    int64
	BytesRead int
}

// RespReadDir is used to transmit ReadDir responses to the client.
type RespReadDir struct {
	// Dst is the data from the read.
	Dst []byte

	// Err is the error represented as a string. Why a string?
	// https://groups.google.com/forum/#!topic/golang-dev/Cua1Av1J8Nc
	// Errors must be sent as strings.
	Err string
}

// ReadDir implements ReadDir on the RPC server side.
func (id FSID) ReadDir(req *ReqReadDir, resp *RespReadDir) error {
	fs, ok := servers[id]
	if !ok {
		return fmt.Errorf("no server for %v", fs)
	}
	var r = &fuseops.ReadDirOp{
		Inode:  req.Inode,
		Handle: req.Handle,
		Offset: fuseops.DirOffset(req.Offset),
		Dst:    make([]byte, req.BytesRead),
	}

	resp.Err = ErrToString(fs.ReadDir(context.TODO(), r))
	if r.BytesRead > 0 {
		resp.Dst = r.Dst[:r.BytesRead]
	}
	return nil
}

// ReadDir implements ReadDir on the RPC client side.
// It processes FUSE requests to forward to the server.
func (fs *Clnt) ReadDir(ctx context.Context, op *fuseops.ReadDirOp) error {
	var resp = &RespReadDir{}
	var req = &ReqReadDir{
		Inode:     op.Inode,
		Handle:    op.Handle,
		Offset:    int64(op.Offset),
		BytesRead: len(op.Dst),
	}
	err := fs.Call("FSID.ReadDir", req, resp)
	if err != nil {
		return err
	}
	copy(op.Dst, resp.Dst)
	op.BytesRead = len(resp.Dst)
	return StringToErr(resp.Err)
}
